//////////////////////////////
/// Scrolling System       ///
/// for Zelda Classic 2.55 ///
/// Alpha 22, or Later     ///
/// v0.5.0                 ///
/// 6th May, 2019          ///
//////////////////////////////
// v0.1.0 : Initial Base
// v0.2.0 : Added Solidity
// v0.3.0 : Changed the scroll script from a hero script to a dmap script.
//        : Moved bitmaps into their own class. Construct on hero init, clear on dmap script. 
//        : This allows us to recycle the same master bitmaps per dmap, so that each dmap change
//        : loads its own dmap script, initialising the values to the maps that we want to use. 
// v0.3.1 : Added a debug function, that writes all current bitmaps to files for inspection, on pressing Ex4. 
// v0.3.2 : Remove Clamp() and constrain movement inside the movement code. 
// v0.4.0 : Added OVERSCAN bitmaps so that the player is not as constrained, but he is still fixed in the centre of the screen.
//        : Changed Link-> pointer use to Hero->
// v0.5.0 : Added a virtual coordinate system, and methods for getting accurate screen IDs, and enemy lists.
//        : Added STRUCT mapInfo, and STRUCT encounter.


script typedef untyped STRUCT;

STRUCT script bitmaps
{
	bitmap resized; //Used for 3d effects
	bitmap scrn; //used to draw the screen
	
	//Map bitmaps.
	bitmap fullmap; //the current, full map
	bitmap fullmap_solid; //solidity of the current map
	bitmap fullmap_type; //combo types on the current map
	bitmap fullmap_flag; //combo flags on the current map
	bitmap fullmap_iflag; //combo inh. flags on the current map
	
	//OVERSCAN bitmaps. These have a generic border, used for Out of Bounds.
	bitmap overscan;
	bitmap overscan_solid;
	bitmap overscan_type;
	bitmap overscan_flag;
	bitmap overscan_iflag;
	bitmap border;
	
	//Sprite bitmaps. 
	bitmap herosprite; //Used to draw the player sprite.
	bitmap heroBUF; //Used as a buffer for the player sprite. 
	
	void Clear()
	{
		resized->Clear(0);	
		scrn->Clear(0);	
		fullmap->Clear(0);	
		fullmap_solid->Clear(0);	
		fullmap_type->Clear(0);	
		fullmap_flag->Clear(0);	
		fullmap_iflag->Clear(0);	
		overscan->Clear(0);	
		overscan_solid->Clear(0);	
		overscan_type->Clear(0);	
		overscan_flag->Clear(0);	
		overscan_iflag->Clear(0);	
		border->Clear(0);	
		herosprite->Clear(0);	
		heroBUF->Clear(0);	
	}
	void Init()
	{
		resized = Game->CreateBitmap(256, 256);
		scrn = Game->CreateBitmap(256, 256);
		
		fullmap = Game->CreateBitmap(256*16, 176*8);
		fullmap_solid = Game->CreateBitmap(256*16, 176*8);
		fullmap_type = Game->CreateBitmap(256*16, 176*8);
		fullmap_flag = Game->CreateBitmap(256*16, 176*8);
		fullmap_iflag = Game->CreateBitmap(256*16, 176*8);
		
		overscan = Game->CreateBitmap(256*18, 176*10);
		overscan_solid  = Game->CreateBitmap(256*18, 176*10);
		overscan_type = Game->CreateBitmap(256*18, 176*10);	
		overscan_flag = Game->CreateBitmap(256*18, 176*10);	
		overscan_iflag = Game->CreateBitmap(256*18, 176*10);
		border = Game->CreateBitmap(256, 176);
		
		herosprite = Game->CreateBitmap(16,16);
		heroBUF = Game->CreateBitmap(16,16);
	}
	void Save()
	{
		resized->Write(0,"sb_resized.png", true);
		scrn->Write(0,"sb_scrn.png", true);
		
		fullmap->Write(0,"sb_fullmap.png", true);
		fullmap_solid->Write(0,"sb_fullmap_solid.png", true);
		fullmap_type->Write(0,"sb_fullmap_type.png", true);
		fullmap_flag->Write(0,"sb_fullmap_flag.png", true);
		fullmap_iflag->Write(0,"sb_fullmap_iflag.png", true);
		
		overscan->Write(0,"sb_OSCfullmap.png", true);
		overscan_solid->Write(0,"sb_OSCfullmap_solid.png", true);
		overscan_type->Write(0,"sb_OSCfullmap_type.png", true);
		overscan_flag->Write(0,"sb_OSCfullmap_flag.png", true);
		overscan_iflag->Write(0,"sb_OSCfullmap_iflag.png", true);
		border->Write(0,"sb_border.png", true);
		
		herosprite->Write(0,"sb_herosprite.png", true);
		heroBUF->Write(0,"sb_heroBUF.png", true);
	}
	
}

STRUCT script mapInfo
{
	int curMap;
	int curScreen;
	int ScreenAt(int x, int y)
	{
		int scr, sc_x, sc_y;
		//Trace(x); Trace(y);
		for ( int q = 256; q < x; q += 256 ) 
		{
			++sc_x;
			//Trace(sc_x);
		}
		for ( int q = 176; q < y; q += 176 ) 
		{
			++sc_y;
			//Trace(sc_y);
		}
		scr = sc_y * 16;
		scr += sc_x;
	
		return scr;
	}
	int getEnemy()
	{
		if ( !mapInfo.curMap ) return 0; 
		mapdata md = Game->LoadMapData(mapInfo.curMap, mapInfo.curScreen);
		int ids[10]; int id = 0; int temp;
		for ( int q = 0; q < 10; ++q ) 
		{
			ids[q] = md->Enemy[q];
			if ( ids[q] ) temp = ids[q];
		}
		if ( !temp ) return 0; //no enemies on this virtual screen, so return early.
		//Get a valid ID of an enemy and return it at random.
		do
		{
			id = ids[Rand(10)];
		} until(id);
		
		return id;
	}
}

STRUCT script encounter
{
	bool init(int xpos, int ypos) //xpos and ypos are the current bitmap coordinates
	{
		mapInfo.curScreen = mapInfo.ScreenAt(xpos,ypos);
		int enem_id = mapInfo.getEnemy();
		if ( !enem_id ) return false;
		//start the encounter here.
		
	}
	
	
}

//The Init script. We initialise bitmaps here. 
hero script h_init
{
	void run()
	{
		bitmaps.Init();
		this->CollDetection = false;
	}
}

dmapdata script scroll
{
	void run()
	{
		mapInfo.curMap = this->Map;
		int frame = 0;
		int lsteps[2]={1,2};
		// bitmap image1 = Game->AllocateBitmap();
		// image1->Read(0,"test.png");
		bitmaps.Clear();
		bitmaps.border->DrawScreen(0, 2, 0, 0, 0, 0);
		
		//Add OVERSCAN to visible map. 
		//top strip
		for ( int q = 0; q < 256*18; q+= 256 )
		{
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, q, 0, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//left side
		for ( int q = 0; q < 176*10; q+=176 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, 0, q, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//right side
		for ( int q = 0; q < 176*10; q+=176 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, 256*17, q, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//bottom strip
		for ( int q = 0; q < 256*18; q+=256 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, q, 176*9, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		
		
		//TraceS("Bitmap Solidity Pointer is: \n"); Trace(bitmaps.fullmap_solid);
		
		
		//draw screens to large map bitmap
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap->DrawScreen(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		//and draw solidity &c to its counterparts
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_solid->DrawScreenSolid(0, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_type->DrawScreenComboTypes(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_flag->DrawScreenComboFlags(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_iflag->DrawScreenComboIFlags(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		
		//copy the large map and its mask counterparts to the OVERSCAN bitmaps
		bitmaps.fullmap->Blit(6, bitmaps.overscan, 0, 0, bitmaps.fullmap->Width, bitmaps.fullmap->Height, 256, 176, 
			bitmaps.fullmap->Width, bitmaps.fullmap->Height,0,0,0,0,0,false);
		
		bitmaps.fullmap_solid->Blit(6, bitmaps.overscan_solid, 0, 0, bitmaps.fullmap_solid->Width, bitmaps.fullmap_solid->Height, 256, 176, 
			bitmaps.fullmap_solid->Width, bitmaps.fullmap_solid->Height,0,0,0,0,0,false);
		//scrn->Rectangle(6, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
		//scrn->DrawLayer(6, 1, 0x01, 0, 0, 0, 0, 128);
		
		bitmap b = Game->CreateBitmap(256, 256);
		
		int pPosX, pPosY;
		int xPos = 256; int yPos = 176; //Positional data starts here. 
		while(1)
		{
			++frame;
			Hero->X = ( 16*8 )-8; //Fixed coordinates int he centre of the screen.
			Hero->Y = (16*7.5)-56-8;
			//LogPrint("Hero->Tile is: %d \n", Hero->Tile);
			bitmaps.herosprite->Clear(0);
			bitmaps.herosprite->FastTile(6, 0,0,Hero->Tile, 6, 128);
			
			if ( Hero->PressEx4 ) bitmaps.Save();
			if ( Hero->PressEx3 )
			{
				LogPrint("Current Virtual Screen: %d \n", mapInfo.ScreenAt(xPos, yPos));
				LogPrint("Current Virtual Map: %d \n", mapInfo.curMap);
			}
			if(Hero->InputLeft)
			{
				//LogPrint("Solidity is: %f \n", Graphics->GetPixel(bitmaps.fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
				//LogPrint("Hero->X is: %d \n", Hero->X);
				//LogPrint("Hero->Y is: %d \n", Hero->Y);
				if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X - ( ((frame&1)) ? lsteps[0] : lsteps[1] ), yPos+Hero->Y+56+8) ) )
				//LogPrint("xPos is: %d \n", xPos);
					//xPos-=5;
				{
					int temp_x_pos = xPos - ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					if ( temp_x_pos >= 0 && temp_x_pos <= (256*15) ) //Might need to extend the <= value out a bit
					{
						xPos = temp_x_pos;
					}
					//else, move the player sprite itself. 
					
				}
			}
			else if(Hero->InputRight)
			{
				//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56+8));
				//LogPrint("Hero->X is: %d \n", Hero->X);
				//LogPrint("Hero->Y is: %d \n", Hero->Y);
				//LogPrint("xPos is: %d \n", xPos);
				if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X + 16 + ( ((frame&1)) ? lsteps[0] : lsteps[1] ), yPos+Hero->Y+56+8) ) )
				{
					//xPos+=5;
					int temp_x_pos = xPos + ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					if ( temp_x_pos >= 0 && temp_x_pos <= (256*15) )  //Might need to extend the <= value out a bit
					{
						xPos = temp_x_pos;
					}
					//else, move the player sprite itself. 
					//xPos += ( ((frame&1)) ? lsteps[0] : lsteps[1] );
				}
			}
				
			if(Hero->InputUp)
			{
				//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
				//LogPrint("yPos is: %d \n", yPos);
			
				if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X+8, yPos+Hero->Y + 56 - ( ((frame&1)) ? lsteps[0] : lsteps[1] )) ) )
				{
					int temp_y_pos = yPos - ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					if ( temp_y_pos >= 0 && temp_y_pos <= (176*7) )  //Might need to extend the <= value out a bit
					{
						yPos = temp_y_pos;
					}
					//else, move the player sprite itself. 
					//yPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
				}
			}
			else if(Hero->InputDown)
			{
				//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
				//LogPrint("yPos is: %d \n", yPos);
				if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X+8, 16+yPos+Hero->Y+56 + ( ((frame&1)) ? lsteps[0] : lsteps[1] )) ))
				{
					//yPos+=5;
					int temp_y_pos = yPos + ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					if ( temp_y_pos >= 0 && temp_y_pos <= (176*7) )  //Might need to extend the <= value out a bit
					{
						yPos = temp_y_pos;
					}
					//else, move the player sprite itself. 
					//yPos += ( ((frame&1)) ? lsteps[0] : lsteps[1] );
				}
			}
			
			//xPos = Clamp(xPos, 0, 256*15);
			//yPos = Clamp(yPos, 0, 176*7);
			
			//blit the current screen slice from the OVERSCAN bitmap, to the temp bitmap used to render the screen.
			bitmaps.scrn->BlitTo(6, bitmaps.overscan, xPos, yPos, 256, 256, 0, 0, bitmaps.resized->Width, bitmaps.resized->Height, 0, 0, 0, 0, 0, false);
			
			int sW = 128;
			int sH = 128;
			//blit the temp screen bitmap to the video bitmap. 
			bitmaps.scrn->Blit(7, -2, 0, 0, 256, 256, 0, -56, 256, 256, 0, 0, 0, 0, 0, false);
			//blit the player sprite to the video bitmap. 
			bitmaps.herosprite->Blit(7, -2, 0, 0, 16, 16, Hero->X, Hero->Y, 16, 16, 0, 0, 0, (( Hero->Dir == DIR_LEFT ) ? BITDX_VFLIP : 0), 0, true);
			
			
			NoAction();
			
			Waitframe();
		}
	}
}

//Drawing Utilities
int VectorX3D(int distance, int yaw, int pitch)
{
	return distance*Sin(pitch)*Cos(yaw);
}

int VectorY3D(int distance, int yaw, int pitch)
{
	return distance*Sin(pitch)*Sin(yaw);
}

int VectorZ3D(int distance, int yaw, int pitch)
{
	return distance*Cos(pitch);
}

void RotateX3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; sz; ++i)
	{
		int y = cy[i];
		int z = cz[i];
		
		cy[i] = y * Cos(angle) - z * Sin(angle);
		cz[i] = z * Cos(angle) + y * Sin(angle);
	}
}

void RotateY3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; i < sz; ++i)
	{
		int x = cx[i];
		int z = cz[i];
		
		cx[i] = x * Cos(angle) - z * Sin(angle);
		cz[i] = z * Cos(angle) + x * Sin(angle);
	}
}

void RotateZ3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; i < sz; ++i )
	{
		int x = cx[i];
		int y = cy[i];
		
		cx[i] = x * Cos(angle) - y * Sin(angle);
		cy[i] = y * Cos(angle) + x * Sin(angle);
	}
}