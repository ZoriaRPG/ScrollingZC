//////////////////////////////
/// Scrolling System       ///
/// for Zelda Classic 2.55 ///
/// Alpha 22, or Later     ///
/// v0.6.2                 ///
/// 6th May, 2019          ///
//////////////////////////////
// v0.1.0 : Initial Base
// v0.2.0 : Added Solidity
// v0.3.0 : Changed the scroll script from a hero script to a dmap script.
//        : Moved bitmaps into their own class. Construct on hero init, clear on dmap script. 
//        : This allows us to recycle the same master bitmaps per dmap, so that each dmap change
//        : loads its own dmap script, initialising the values to the maps that we want to use. 
// v0.3.1 : Added a debug function, that writes all current bitmaps to files for inspection, on pressing Ex4. 
// v0.3.2 : Remove Clamp() and constrain movement inside the movement code. 
// v0.4.0 : Added OVERSCAN bitmaps so that the player is not as constrained, but he is still fixed in the centre of the screen.
//        : Changed Link-> pointer use to Hero->
// v0.5.0 : Added a virtual coordinate system, and methods for getting accurate screen IDs, and enemy lists.
//        : Added STRUCT mapInfo, and STRUCT encounter.
// v0.5.1 : Added additional encounter system code.
// v0.5.2 : Added check for slow walk combos. 
// v0.5.3 : Added mock encounter visual effects.
//        : Don't draw the player sprite, or allow scrolling during an encounter.
// v0.5.4 : Changed rate on slow walk tiles (hills) to be less sluggish.
// v0.6.0 : Begin adding menus.
// v0.6.1 : Added dice namespace, added global init script, added some menu initialisation.
// v0.6.2 : Removed some namespaces, because of array bugs in ZC>
//        : Added a STRUCT script for the statsmenu.
//        : Added a STRUCT script for the vitals.
//        : Draw the stats menu. 
//        : Disabled some traces.
// v0.6.3 : Added menu STRUCT. 
//        : Added menutype ENUM.
// v0.7.0 : Begin adding spells.
// v0.7.1 : Fix pseudo-2d array access. 


script typedef untyped STRUCT;
typedef const int def;

enum menutype { mNone, mStats, mBattle, mCommand, mDialogue, mInventory, mShop, mInn, mSpell };
enum stattype { level, hp, mp, gold, exp, str, dex, wis, con, cha, mind, soul, luck };
enum spelltype { heal, hurt, light, fire, firemore, healmore, hurtmore, healmost, firemost, hurtmost, exit, warp };
enum spelleffect { FXnone, FXflash };

STRUCT script spells
{
	spelltype current;
	enum{ str, cost, effect, duration, last };
	int data[<int>warp+1, last]; //[<int>warp]; //2d array
	
	
	void cast(spelltype spell)
	{
		switch(spell)
		{
			case heal: break;
			case hurt: break;
			case light: break;
			case fire: break;
			case firemore: break;
			case healmore: break;
			case hurtmore: break;
			case healmost: break;
			case firemost: break;
			case hurtmost: break;
			case warp: break;
			case heal: break;
			case heal: break;
			case heal: break;
			default: break;
			
		}
		
	}
	void init(int first_str) //stores the string ID, the cost, and the effect for each spell, using ths string editor
	//string format is: 
	//name 000 @effect
	//example: 
	//blaze 8 @flash
	{
		int sz = SizeOfArray(data);
		//string format SPELLNAME 000 @effects
		//example: hurtmore, 4 @2
		for ( int q = 0; q < <int>warp+1; ++q )
		{
			for ( int w = 0; w < last; ++ w) 
			{
				data[q,str] = first_str; //first_str is also the current string that we are reading
				int chr[256];
				int the_cost[5];
				int the_effect[5];
				//int effect[3];
				int effect_buf[16];
				Game->GetMessage(data[q,str], chr);
				//strip trailing spaces
				for ( int w = 255; chr[w] != ' ' && chr[w] != 0; --w )
				{
					chr[w] = 0; //clear trailing spaces
				}
				//get only the cost.
				int pos;
				for ( int qw = 0; chr[qw] != 0; ++qw )
				{
					if ( isNumber(chr[qw]) ) //store the cost that is in the string here.
					{
						if ( chr[qw] == '@' ) break;
						the_cost[pos] = chr[qw];
						++pos;
					}
				}
				data[q,cost] = atoi(the_cost);
				//get the effect
				until(chr[pos] == '@')
				{
					if ( !chr[pos] ) LogPrint("String entry for spell string %d was missign the effect arg. \n", first_str);
					++pos;
				} 
				++pos; //slip delimiter
				int effect_pos;
				while(chr[pos] != 0) 
				{
					//store the effect type
					the_effect[effect_pos] = chr[pos];
					++pos;
					++effect_pos;
				}
				if ( !strcmp(effect, "none") ) data[q,effect] = <int>FXnone;
				if ( !strcmp(effect, "flash") ) data[q,effect] = <int>FXflash;
				
				//while(char[pos] != 0 && isNumber(char[pos]) ) //store the effect ID
				//{
				//	effect[effect_pos] = char[pos];
				//	++pos;
				//	++effect_pos;
				//}
				++first_str;
			}
			
		}
		
		int name[256];
		
		
		
		
	}
}

STRUCT script vital
{
	enum { level, hp, mp, gold, exp, str, dex, wis, con, cha, mind, soul, luck, last };
	int stat[last];
	void set(int statid, int v)
	{
		stat[statid] = v;
	}
	void reduce(int statid)
	{
		--stat[statid];
	}
	void reduce(int statid, int v)
	{
		stat[statid]-=v;
	}
	void increase(int statid)
	{
		++stat[statid];
	}
	void increase(int statid, int v)
	{
		stat[statid]+=v;
	}
	float get(int statid)
	{
		return stat[statid];
	}
	void set(int ptr)
	{
		if ( SizeOfArray(ptr) != last )
		{
			LogPrint("Array passed to stats.set(*ptr) is the wrong size [ %d", SizeOfArray(ptr));
			LogPrint(" ]. \n You must use an array sized to [ %d", last);
			LogPrint(" ] %s \n", "for this function.");
			return;
		}
		for ( int q = 0; q < last; ++q )
		{
			stat[q] = ptr[q];
		}
		
	}
	void init(int ptr) { set(ptr); } 
	
}

STRUCT script menu
{
	enum { selection, last = 64 };
	const int DATA_LAST = 64;
	menutype current;
	
	int data[last];
}

/*
	
void Blit	( int layer, 
			bitmap target, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation, int cx, int cy, int mode, int lit,  bool mask);
			
 * BLITS THE BITMAP ON POINTER 'b' TO A TARGET BITMAP. 
 * As DrawBitmapEx(), except that it draws FROM an initialised bitmap pointer,
 * TO a target bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap target'.
 * To draw to a user created bitmap, pass its pointer to 'bitmap target'.
*/

namespace dice
{
	int roll(int sides)
	{
		return Rand(sides)+1;
	}
}

STRUCT script statsmenu
{
	enum { valid, x, y, selection, cursor, numOptions, colour, font, font_height, font_width, kerning, background, width, height, messages, curMsg, last };

	def MAX_MESSAGES = 10;
	def MAX_VALUES = 10;
	bitmap bitty;
	def bWidth = 64;
	def bHeight = 96;
	def X = 0;
	def Y = 0;
	def FONT = FONT_FF;
	def FONT_H = 16;
	def FONT_W = 16;
	def KERN = 4;
	def BG = 0x0F;
	def COLOUR = 0x01;
	int data[last];
	int values[MAX_VALUES]; //stat values
	int msg[MAX_MESSAGES]; //menu text lines
	
	void init(int ptr)
	{
		bitty = Game->CreateBitmap(bWidth,bHeight);
		
		setProperties(ptr);
	}
	void init()
	{
		bitty = Game->CreateBitmap(bWidth,bHeight);
		for ( int q = 0; q < vital.last; ++q )
		{
			values[q] = vital.stat[q];
		}
		//setProperties(ptr);
	}
	void draw()
	{
		int curmsg[256]; int curvalue[10];
		int text_y = 4; int len_x;
		//LogPrint("current number of options is: %d \n", data[numOptions]);
		//for ( int q = 0; q < SizeOfArray(msg); ++q )
		//{
		//	LogPrint("msg[] %d is %d \n", q, msg[q]);
		//}			
		for ( int q = 0; q < data[numOptions]; ++q )
		{
			//LogPrint("Current message in draw() is %d \n", msg[q]);
			//messagedata md = Game->LoadMessageData(msg[q]);
			Game->GetMessage(msg[q], curmsg);
			//TraceS(curmsg);
			//md->Get(curmsg);
			for ( int w = 255; curmsg[w] != ' ' && curmsg[w] != 0; --w )
			{
				curmsg[w] = 0; //clear trailing spaces
			}
			//LogPrint("values[] %d is %d \n", q, values[q]);
			itoa(curvalue, values[q]);
			int spacing[10];
			spacing[q] = strlen(curvalue); //Chars are variable width. We need a text map of them as an enum. 
			//for ( int ww = 0; curvalue[ww] != 0; ++ww ) len_x += data[font_width]; //Get numerical text width
			//LogPrint("Menu message is: %s \n", curmsg);
			bitty->Rectangle(0, 0, 0, bitty->Width-1, bitty->Height-1, 0x4F, -1, 0,0,0,true,128);
			bitty->Rectangle(0, 1, 1, bitty->Width-2, bitty->Height-2, 0x01, -1, 0,0,0,true,128);
			bitty->Rectangle(0, 2, 2, bitty->Width-3, bitty->Height-3, 0x4F, -1, 0,0,0,true,128);
			bitty->DrawString(6,4, text_y, data[font], data[colour], -1, 0, curmsg, 128);
			bitty->DrawString(6,bitty->Width - 18, text_y, data[font], data[colour], -1, 0, curvalue, 128);
			text_y += data[font_height] + data[kerning];
			//wipe itoa buffer
			for ( int a = 0; a < 10; ++a ) curvalue[a] = 0;
			
		}
		
		bitty->Blit(7, bitmaps.scrn, 0, 0, bitty->Width, bitty->Height, data[x], data[y], bitty->Width, bitty->Height, 0,0,0,((encounter.valid) ? 0 : BITDX_TRANS),0,false); 
	}
	void setCurMessage(int m)
	{
		//msg[data[curMsg]] = m;
		//++data[curMsg];
	}
	void setMessages(int first, int num)
	{
		//messagedata md;
		//LogPrint("setMessages(first,num) data[numOptions] is %d \n", data[numOptions]);
		for(int q = 0; q < num; ++q )
		{
			//md = Game->LoadMessageData(q+first);
			msg[q] = first+q;
		}
	}
	void set(int p, int v)
	{
		if ( p < 0 || p > (last-1) ) 
		{
			LogPrint("Invalid menu property [ %d ", p);
			LogPrint("] passed to set(). Min value is 0, max is %d. \n", last-1);
			return;
		}
		data[p] = v;
	}
	void setMessage(int mID, int msg)
	{
		if ( mID < 0 || mID > (MAX_MESSAGES-1) ) 
		{
			LogPrint("Invalid message index ID [ %d ", mID);
			LogPrint("] passed to setMessage. Min index is 0, max is %d. \n", (MAX_MESSAGES-1));
			return;
		}
		msg[mID] = msg;
	}
	void setMessages(int ptr)
	{
		if ( SizeOfArray(ptr) != MAX_MESSAGES ) 
		{
			LogPrint("Array passed to setMenuProperties() is the wrong size [ %d ", SizeOfArray(ptr));
			LogPrint("]. \n The array must be a size of [ %d ", last);
			LogPrint("] %s \n", "Aborting.");
			return;
		}
		for ( int q = 0; q < last; ++q ) 
		{
			msg[q] = ptr[q];
		}
	}
	void setProperties(int ptr)
	{
		int p = ptr;
		if ( SizeOfArray(p) != last ) 
		{
			LogPrint("Array passed to setMenuProperties() is the wrong size [ %d ", SizeOfArray(p));
			LogPrint("]. \n The array must be a size of [ %d ", last);
			LogPrint("] %s \n", "Aborting.");
			return;
		}
		for ( int q = 0; q < last; ++q ) 
		{
			data[q] = p[q];
		}
		
	}
	void setMenuProperties(int m_valid, int m_x, int m_y, int m_selection, int m_numOptions, int m_colour, int m_font, int m_font_height,
		int m_font_width, int m_kerning,
		int m_background, int m_width, int m_height, int m_messages, int m_curMsg)
	{
		data[valid] = m_valid;
		data[selection] = m_selection;
		data[numOptions] = m_numOptions;
		data[colour] = m_colour;
		data[font] = m_font;
		data[font_height] = m_font_height; 
		data[font_width] = m_font_width; 
		data[kerning] = m_kerning;
		data[background] = m_background;
		data[x] = m_x;
		data[y] = m_y;
		data[width] = m_width;
		data[height] = m_height;
		data[messages] = m_messages;
		data[curMsg] = m_curMsg;
		
	}
	
}

STRUCT script bitmaps
{
	bitmap resized; //Used for 3d effects
	bitmap scrn; //used to draw the screen
	
	//Map bitmaps.
	bitmap fullmap; //the current, full map
	bitmap fullmap_solid; //solidity of the current map
	bitmap fullmap_type; //combo types on the current map
	bitmap fullmap_flag; //combo flags on the current map
	bitmap fullmap_iflag; //combo inh. flags on the current map
	
	//OVERSCAN bitmaps. These have a generic border, used for Out of Bounds.
	bitmap overscan;
	bitmap overscan_solid;
	bitmap overscan_type;
	bitmap overscan_flag;
	bitmap overscan_iflag;
	bitmap border;
	
	//Sprite bitmaps. 
	bitmap herosprite; //Used to draw the player sprite.
	bitmap heroBUF; //Used as a buffer for the player sprite. 
	bitmap enemyQuad;
	bitmap enemyBUF;
	
	void Clear()
	{
		resized->Clear(0);	
		scrn->Clear(0);	
		fullmap->Clear(0);	
		fullmap_solid->Clear(0);	
		fullmap_type->Clear(0);	
		fullmap_flag->Clear(0);	
		fullmap_iflag->Clear(0);	
		overscan->Clear(0);	
		overscan_solid->Clear(0);	
		overscan_type->Clear(0);	
		overscan_flag->Clear(0);	
		overscan_iflag->Clear(0);	
		border->Clear(0);	
		herosprite->Clear(0);	
		heroBUF->Clear(0);
		enemyQuad->Clear(0);
		enemyBUF->Clear(0);		
	}
	void Init()
	{
		resized = Game->CreateBitmap(256, 256);
		scrn = Game->CreateBitmap(256, 256);
		
		fullmap = Game->CreateBitmap(256*16, 176*8);
		fullmap_solid = Game->CreateBitmap(256*16, 176*8);
		fullmap_type = Game->CreateBitmap(256*16, 176*8);
		fullmap_flag = Game->CreateBitmap(256*16, 176*8);
		fullmap_iflag = Game->CreateBitmap(256*16, 176*8);
		
		overscan = Game->CreateBitmap(256*18, 176*10);
		overscan_solid  = Game->CreateBitmap(256*18, 176*10);
		overscan_type = Game->CreateBitmap(256*18, 176*10);	
		overscan_flag = Game->CreateBitmap(256*18, 176*10);	
		overscan_iflag = Game->CreateBitmap(256*18, 176*10);
		border = Game->CreateBitmap(256, 176);
		
		herosprite = Game->CreateBitmap(16,16);
		heroBUF = Game->CreateBitmap(16,16);
		
		enemyQuad = Game->CreateBitmap(128,96);
		enemyBUF = Game->CreateBitmap(128,96);
	}
	void Save()
	{
		resized->Write(0,"sb_resized.png", true);
		scrn->Write(0,"sb_scrn.png", true);
		
		fullmap->Write(0,"sb_fullmap.png", true);
		fullmap_solid->Write(0,"sb_fullmap_solid.png", true);
		fullmap_type->Write(0,"sb_fullmap_type.png", true);
		fullmap_flag->Write(0,"sb_fullmap_flag.png", true);
		fullmap_iflag->Write(0,"sb_fullmap_iflag.png", true);
		
		overscan->Write(0,"sb_OSCfullmap.png", true);
		overscan_solid->Write(0,"sb_OSCfullmap_solid.png", true);
		overscan_type->Write(0,"sb_OSCfullmap_type.png", true);
		overscan_flag->Write(0,"sb_OSCfullmap_flag.png", true);
		overscan_iflag->Write(0,"sb_OSCfullmap_iflag.png", true);
		border->Write(0,"sb_border.png", true);
		
		herosprite->Write(0,"sb_herosprite.png", true);
		heroBUF->Write(0,"sb_heroBUF.png", true);
	}
	
}

STRUCT script mapInfo
{
	int curMap;
	int curScreen;
	bool canScroll = true;
	int ScreenAt(int x, int y)
	{
		int scr, sc_x, sc_y;
		//Trace(x); Trace(y);
		for ( int q = 256; q < x; q += 256 ) 
		{
			++sc_x;
			//Trace(sc_x);
		}
		for ( int q = 176; q < y; q += 176 ) 
		{
			++sc_y;
			//Trace(sc_y);
		}
		scr = sc_y * 16;
		scr += sc_x;
	
		return scr;
	}
	int getEnemy()
	{
		if ( !mapInfo.curMap ) return 0; 
		mapdata md = Game->LoadMapData(mapInfo.curMap, mapInfo.curScreen);
		int ids[10]; int id = 0; int temp;
		for ( int q = 0; q < 10; ++q ) 
		{
			ids[q] = md->Enemy[q];
			if ( ids[q] ) temp = ids[q];
		}
		if ( !temp ) return 0; //no enemies on this virtual screen, so return early.
		//Get a valid ID of an enemy and return it at random.
		do
		{
			id = ids[Rand(10)];
		} until(id);
		
		return id;
	}
	//Get information about combos on the maps. 
	bool comboS(int xpos, int ypos)
	{
		return (Graphics->GetPixel(bitmaps.overscan_solid,xpos+Hero->X + 8, ypos+Hero->Y+56+8));
	}
	//int getComboSolidity()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_solid,xpos+Hero->X + 8, ypos+Hero->Y+56+8)*10000);
	//}
	int comboT(int xpos, int ypos)
	{
		return (Graphics->GetPixel(bitmaps.overscan_type,xpos+Hero->X + 8, ypos+Hero->Y+56+8) * 10000);
	}
	int comboF(int xpos, int ypos)
	{
		return (Graphics->GetPixel(bitmaps.overscan_flag,xpos+Hero->X + 8, ypos+Hero->Y+56+8) * 10000);
	}
	int comboI(int xpos, int ypos)
	{
		return (Graphics->GetPixel(bitmaps.overscan_iflag,xpos+Hero->X + 8, ypos+Hero->Y+56+8) * 10000);
	}
}

STRUCT script encounter
{
	int terrain_type; int valid;
	enum { terFIELD, terFOREST, terHILL, terSWAMP, terDUNGEON, terVILL, terCASTLE, terDARK, terLAST };
	bool init(int xpos, int ypos) //xpos and ypos are the current bitmap coordinates
	{
		terrain_type = mapInfo.comboI(xpos,ypos); //Inh flag for terrain type.
		//We will use this for backgrounds on the enemy quads. 
		mapInfo.curScreen = mapInfo.ScreenAt(xpos,ypos);
		int enem_id = mapInfo.getEnemy();
		if ( !enem_id ) return false;
		//start the encounter here.
		valid = enem_id;
		mapInfo.canScroll = false;
		
		//Mock encounter
		LogPrint("Mock Encounter got an enemy ID of %d \n", enem_id);
		return true;
		
	}
	void draw()
	{
		bitmaps.enemyQuad->Clear(0);
		bitmaps.enemyBUF->Clear(0);
		switch(terrain_type)
		{
			//might need to load a palette, too?
			case terFIELD: bitmaps.enemyBUF->Read(0, "dq_terr_field.png"); break;
			case terFOREST: bitmaps.enemyBUF->Read(0, "dq_terr_forest.png"); break;
			case terHILL: bitmaps.enemyBUF->Read(0, "dq_terr_hill.png"); break;
			case terSWAMP: bitmaps.enemyBUF->Read(0, "dq_terr_swamp.png"); break;
			case terDUNGEON: bitmaps.enemyBUF->Read(0, "dq_terr_dungeon.png"); break;
			case terVILL: bitmaps.enemyBUF->Read(0, "dq_terr_towne.png"); break;
			case terCASTLE: bitmaps.enemyBUF->Read(0, "dq_terr_castle.png"); break;
			case terDARK: 
			default: bitmaps.enemyBUF->Read(0, "dq_terr_darkness.png"); break;
		}
		
		
		bitmaps.enemyBUF->Blit(7, bitmaps.scrn, 0, 0, bitmaps.enemyBUF->Width, bitmaps.enemyBUF->Height, 64, 64, 
				bitmaps.enemyBUF->Width, bitmaps.enemyBUF->Height,0,0,0,0,0,false);
	}
	
	
}

global script Init
{
	void run()
	{
		vital.init({1, 16, 0, 20, 0, dice::roll(6), dice::roll(6), dice::roll(6), dice::roll(6), dice::roll(6), dice::roll(6), dice::roll(6), dice::roll(6) });
		//for ( int q = 0; q < 13; ++q ) LogPrint("vital.stat[] %d is %d \n", q, vital.stat[q]);
		//level, hp, mp, gold, exp, str, dex, wis, con, cha, mind, soul, luck, last };
		//statsmenu.init({1, statsmenu.X, statsmenu.Y, -1, -1, -1, statsmenu.COLOUR, statsmenu.FONT, statsmenu.FONT_H, 
		//	statsmenu.FONT_W, statsmenu.KERN, statsmenu.BG, statsmenu.bWidth, statsmenu.bHeight, statsmenu.msg, -1});
		statsmenu.init();
		statsmenu.setMenuProperties(1, statsmenu.X, statsmenu.Y, -1, 5, statsmenu.COLOUR, statsmenu.FONT, statsmenu.FONT_H,
			statsmenu.FONT_W, statsmenu.KERN, statsmenu.BG, statsmenu.bWidth, statsmenu.bHeight, statsmenu.msg, -1);
		
		statsmenu.setMessages(1, 5);
	}
}

//The Init script. We initialise bitmaps here. 
hero script h_init
{
	void run()
	{
		//menu::init();
		bitmaps.Init();
		//statsmenu.setMessages(1, 5);
		this->CollDetection = false;
	}
}

dmapdata script scroll
{
	void run()
	{
		mapInfo.curMap = this->Map;
		int frame = 0;
		int lsteps[2]={1,2};
		// bitmap image1 = Game->AllocateBitmap();
		// image1->Read(0,"test.png");
		bitmaps.Clear();
		bitmaps.border->DrawScreen(0, 2, 0, 0, 0, 0);
		
		//Add OVERSCAN to visible map. 
		//top strip
		for ( int q = 0; q < 256*18; q+= 256 )
		{
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, q, 0, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//left side
		for ( int q = 0; q < 176*10; q+=176 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, 0, q, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//right side
		for ( int q = 0; q < 176*10; q+=176 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, 256*17, q, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		//bottom strip
		for ( int q = 0; q < 256*18; q+=256 )
		{
			
			bitmaps.border->Blit(6, bitmaps.overscan, 0, 0, bitmaps.border->Width, bitmaps.border->Height, q, 176*9, 
			bitmaps.border->Width, bitmaps.border->Height,0,0,0,0,0,false);
		}
		
		
		//TraceS("Bitmap Solidity Pointer is: \n"); Trace(bitmaps.fullmap_solid);
		
		
		//draw screens to large map bitmap
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap->DrawScreen(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		//and draw solidity &c to its counterparts
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_solid->DrawScreenSolid(0, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_type->DrawScreenComboTypes(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_flag->DrawScreenComboFlags(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		for(int i=0; i<128; i++)
		{
			bitmaps.fullmap_iflag->DrawScreenComboIFlags(6, 1, i, (i%16)*256, Floor(i/16)*176, 0);
		}
		
		//copy the large map and its mask counterparts to the OVERSCAN bitmaps
		bitmaps.fullmap->Blit(6, bitmaps.overscan, 0, 0, bitmaps.fullmap->Width, bitmaps.fullmap->Height, 256, 176, 
			bitmaps.fullmap->Width, bitmaps.fullmap->Height,0,0,0,0,0,false);
		
		bitmaps.fullmap_solid->Blit(6, bitmaps.overscan_solid, 0, 0, bitmaps.fullmap_solid->Width, bitmaps.fullmap_solid->Height, 256, 176, 
			bitmaps.fullmap_solid->Width, bitmaps.fullmap_solid->Height,0,0,0,0,0,false);
		
		
		bitmaps.fullmap_type->Blit(6, bitmaps.overscan_type, 0, 0, bitmaps.fullmap_type->Width, bitmaps.fullmap_type->Height, 256, 176, 
			bitmaps.fullmap_type->Width, bitmaps.fullmap_type->Height,0,0,0,0,0,false);
		
		bitmaps.fullmap_flag->Blit(6, bitmaps.overscan_flag, 0, 0, bitmaps.fullmap_flag->Width, bitmaps.fullmap_flag->Height, 256, 176, 
			bitmaps.fullmap_flag->Width, bitmaps.fullmap_flag->Height,0,0,0,0,0,false);
		
		bitmaps.fullmap_iflag->Blit(6, bitmaps.overscan_iflag, 0, 0, bitmaps.fullmap_iflag->Width, bitmaps.fullmap_iflag->Height, 256, 176, 
			bitmaps.fullmap_iflag->Width, bitmaps.fullmap_iflag->Height,0,0,0,0,0,false);
		//scrn->Rectangle(6, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
		//scrn->DrawLayer(6, 1, 0x01, 0, 0, 0, 0, 128);
		
		bitmap b = Game->CreateBitmap(256, 256);
		
		int pPosX, pPosY;
		int xPos = 256; int yPos = 176; //Positional data starts here. 
		while(1)
		{
			++frame;
			Hero->X = ( 16*8 )-8; //Fixed coordinates int he centre of the screen.
			Hero->Y = (16*7.5)-56-8;
			//LogPrint("Hero->Tile is: %d \n", Hero->Tile);
			bitmaps.herosprite->Clear(0);
			bitmaps.herosprite->FastTile(6, 0,0,Hero->Tile, 6, 128);
			
			if ( Hero->PressEx4 ) bitmaps.Save();
			
			
			if ( Hero->PressEx3 )
			{
				LogPrint("Current Virtual Screen: %d \n", mapInfo.ScreenAt(xPos, yPos));
				LogPrint("Current Virtual Map: %d \n", mapInfo.curMap);
			}
			if ( mapInfo.canScroll )
			{
				if(Hero->InputLeft)
				{
					//LogPrint("Solidity is: %f \n", Graphics->GetPixel(bitmaps.fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
					//LogPrint("Hero->X is: %d \n", Hero->X);
					//LogPrint("Hero->Y is: %d \n", Hero->Y);
					if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X - (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] )), yPos+Hero->Y+56+8) ) )
					//LogPrint("xPos is: %d \n", xPos);
						//xPos-=5;
					{
						int temp_x_pos = xPos - (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ));
						//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
						if ( temp_x_pos >= 0 && temp_x_pos <= (256*15) ) //Might need to extend the <= value out a bit
						{
							xPos = temp_x_pos;
						}
						//else, move the player sprite itself. 
						
					}
				}
				else if(Hero->InputRight)
				{
					//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56+8));
					//LogPrint("Hero->X is: %d \n", Hero->X);
					//LogPrint("Hero->Y is: %d \n", Hero->Y);
					//LogPrint("xPos is: %d \n", xPos);
					if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X + 16 + (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] )), yPos+Hero->Y+56+8) ) )
					{
						//xPos+=5;
						int temp_x_pos = xPos + (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ));
						//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
						if ( temp_x_pos >= 0 && temp_x_pos <= (256*15) )  //Might need to extend the <= value out a bit
						{
							xPos = temp_x_pos;
						}
						//else, move the player sprite itself. 
						//xPos += ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					}
				}
					
				if(Hero->InputUp)
				{
					//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
					//LogPrint("yPos is: %d \n", yPos);
				
					if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X+8, yPos+Hero->Y + 56 - (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ))) ) )
					{
						int temp_y_pos = yPos - (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ));
						//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
						if ( temp_y_pos >= 0 && temp_y_pos <= (176*7) )  //Might need to extend the <= value out a bit
						{
							yPos = temp_y_pos;
						}
						//else, move the player sprite itself. 
						//yPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					}
				}
				else if(Hero->InputDown)
				{
					//LogPrint("Solidity is: %f \n", Graphics->GetPixel(fullmap_solid,xPos+Hero->X, yPos+Hero->Y+56));
					//LogPrint("yPos is: %d \n", yPos);
					if (!(Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X+8, 16+yPos+Hero->Y+56 + (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ))) ))
					{
						//yPos+=5;
						int temp_y_pos = yPos + (( ( mapInfo.comboT(xPos,yPos) == CT_SLOWWALK ) ) ? ( ((frame&1)) ? 2 : 0 ) : ( ((frame&1)) ? lsteps[0] : lsteps[1] ));
						//xPos -= ( ((frame&1)) ? lsteps[0] : lsteps[1] );
						if ( temp_y_pos >= 0 && temp_y_pos <= (176*7) )  //Might need to extend the <= value out a bit
						{
							yPos = temp_y_pos;
						}
						//else, move the player sprite itself. 
						//yPos += ( ((frame&1)) ? lsteps[0] : lsteps[1] );
					}
				}
			}
			//xPos = Clamp(xPos, 0, 256*15);
			//yPos = Clamp(yPos, 0, 176*7);
			
			//blit the current screen slice from the OVERSCAN bitmap, to the temp bitmap used to render the screen.
			bitmaps.scrn->BlitTo(6, bitmaps.overscan, xPos, yPos, 256, 256, 0, 0, bitmaps.resized->Width, bitmaps.resized->Height, 0, 0, 0, 0, 0, false);
			if ( Hero->PressEx2 ) encounter.init(xPos,yPos);
			if ( encounter.valid ) encounter.draw();
			statsmenu.draw();
			if ( Hero->PressEx1 ) { encounter.valid = 0; mapInfo.canScroll = true; } //end the encounter.
			int sW = 128;
			int sH = 128;
			//blit the temp screen bitmap to the video bitmap. 
			bitmaps.scrn->Blit(7, -2, 0, 0, 256, 256, 0, -56, 256, 256, 0, 0, 0, 0, 0, false);
			//blit the player sprite to the video bitmap. 
			if ( !encounter.valid ) bitmaps.herosprite->Blit(7, -2, 0, 0, 16, 16, Hero->X, Hero->Y, 16, 16, 0, 0, 0, (( Hero->Dir == DIR_LEFT ) ? BITDX_VFLIP : 0), 0, true);
			
			
			NoAction();
			
			Waitframe();
		}
	}
	//bool getComboSolid()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X + 8, yPos+Hero->Y+56+8));
	//}
	//int getComboSolidity()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_solid,xPos+Hero->X + 8, yPos+Hero->Y+56+8)*10000);
	//}
	//int getComboType()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_type,xPos+Hero->X + 8, yPos+Hero->Y+56+8) * 10000);
	//}
	//int getComboFlag()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_flag,xPos+Hero->X + 8, yPos+Hero->Y+56+8) * 10000);
	//}
	//int getComboIFlag()
	//{
	//	return (Graphics->GetPixel(bitmaps.overscan_iflag,xPos+Hero->X + 8, yPos+Hero->Y+56+8) * 10000);
	//}
}

//Drawing Utilities
int VectorX3D(int distance, int yaw, int pitch)
{
	return distance*Sin(pitch)*Cos(yaw);
}

int VectorY3D(int distance, int yaw, int pitch)
{
	return distance*Sin(pitch)*Sin(yaw);
}

int VectorZ3D(int distance, int yaw, int pitch)
{
	return distance*Cos(pitch);
}

void RotateX3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; sz; ++i)
	{
		int y = cy[i];
		int z = cz[i];
		
		cy[i] = y * Cos(angle) - z * Sin(angle);
		cz[i] = z * Cos(angle) + y * Sin(angle);
	}
}

void RotateY3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; i < sz; ++i)
	{
		int x = cx[i];
		int z = cz[i];
		
		cx[i] = x * Cos(angle) - z * Sin(angle);
		cz[i] = z * Cos(angle) + x * Sin(angle);
	}
}

void RotateZ3D(int angle, int cx, int cy, int cz)
{
	int sz = SizeOfArray(cx);
	for(int i=0; i < sz; ++i )
	{
		int x = cx[i];
		int y = cy[i];
		
		cx[i] = x * Cos(angle) - y * Sin(angle);
		cy[i] = y * Cos(angle) + x * Sin(angle);
	}
}